# CQRS(Command Query Responsibility Segregation)
`CQRS` 뜻에서 알 수 있듯이 `DB`로부터 쓰기 작업과 읽기 작업의 책임을 분리하는 패턴을 말합니다.
기존 아키텍쳐에서는 `DB`의 쓰기 작업과 읽기 작업을 한 모델이 수행하였습니다. 하지만 프로젝트의 규모가 커지고 유지 보수가 어려워지면서 형식이 다른 두 작업을 **하나의 모델**이 수행하게 된다면 너무 많은 작업을 수행하게 되어 각 작업에 따라 다른 성능이 요구되어 성능이 저하될 수 있습니다.

이러한 이유 때문에 `CQRS` 패턴을 사용합니다.

`Command`는 수행할 작업의 중심이 됩니다. 그리고 동기적이 아닌 비동기적으로 큐에 쌓여 수행됩니다.
`Query`는 `DB`의 상태를 절대 변화시키지 않습니다.

이렇게 쓰기와 읽기 모델을 분리하면 어플리케이션의 디자인과 구현을 간단하게 만들어줍니다.
그리고 두 작업을 확실하게 격리하기 위해서 쓰기 모델의 `DB`는 `RDBMS`를 사용하고 읽기 모델의 `DB`는 `NoSQL`을 사용하는 것처럼 두 작업의 DB를 다르게 사용할 수도 있습니다. 이 때 DB 업데이트와 이벤트 발행은 반드시 한 트랜잭션 안에서 이루어져야 합니다.

![Image](https://github.com/user-attachments/assets/ec6ed538-ea7a-414b-95d0-c14f51b934aa)

## 장점
- `최적화된 데이터 스키마`: 읽기 작업의 모델과 쓰기 작업의 모델을 분리하기 때문에 읽기 작업에 최적화된 스키마를 사용할 수 있고, 쓰기 작업에는 쓰기 작업에 최적화된 스키마를 사용할 수 있습니다.
- `보안`: 읽기 작업과 쓰기 작업을 분리하기 때문에 보안에 용이해집니다.
- `관심사 분리`: 작업을 두 개로 분리함으로써 애플리케이션의 유지보수가 더 쉬워지고 유연해집니다.
- `독립적인 스케일링`: 읽기와 쓰기에 대한 스케일링하여 `Lock 경합`을 줄여줍니다.
## 단점
- 전체 애플리케이션의 복잡도가 증가합니다.
- 쓰기 모델과 읽기 모델을 동기화해야하기 때문에 동기화 전략이 필요합니다.
## 참고 자료
- https://mslim8803.tistory.com/73
- https://sabarada.tistory.com/227
- https://bluayer.com/37
- https://azderica.github.io/02-architecture-msa/